import numpy as np
import scipy.optimize as opt
from collections import deque
import copy
import location as loc
import os
import sys
import matplotlib.pyplot as plt

#Data files generated by this file
# ***** Time Domain ******
#Frequency vs time
#Acceleration vs time
#Residuals of sine of angle vs time
#Residuals of sine of angle vs angle
#Angle jitter vs time
#Angle jitter vs angle
# ***** Frequency Domain *****
#FFT of sine of angle
#PSD of sine of angle
#FFT of cosine of angle
#PSD of cosine of angle
#Complex FFT of angle
#Complex PSD of angle
#FFT of angle jitter
#PSD of angle jitter
#FFT of sine of angle residual
#PSD of sine of angle residual
# ****** Clock Time Domain *****
# Clock jitter vs count
# Clock jitter vs clock
# ***** Clock Frequency Domain *****
#FFT of sine of clock
#PSD of sine of clock
#FFT of cosine of clock
#PSD of cosine of clock
#Complex FFT of clock
#Complex PSD of clock
#FFT of clock jitter
#PSD of clock jitter

#Custom window function to be used for the FFT
def windowFunc(alen, timestep, rotFreq=2., cutoffWavelengths=10):
    period = 1./rotFreq
    return np.array([np.sin((np.pi/2)*((timestep*i)/(period*cutoffWavelengths))) if timestep*i < period*cutoffWavelengths else np.sin((np.pi/2)*((timestep*(alen-1-i))/(period*cutoffWavelengths))) if timestep*(alen-1-i) <= period*cutoffWavelengths else 1. for i in range(alen)])

#Number of ticks per revolution
ticksPerRev = 1140
#Downselection of arrays for faster processing
ds = 1

#****************** Main ***************************

# Portion of the code that runs
if __name__ == '__main__':
    #Use command-line arguments to obtain locaiton of the data to be processed
    args = sys.argv[1:]
    if not len(args) == 1:
        sys.exit("Usage: python encoderDataAnalyze.py [Run Name]\n")
    else:
        runName = str(args[0])
        loadDir = loc.masterDir+runName+"/Data/"
        if not os.path.exists(loadDir):
            sys.exit("FATAL: Data directory %s not found\n" % (loadDir))
        saveDir = loadDir

    # ********************************************************
    # Load Data
    # ********************************************************

    #Data files
    fname1 = loadDir+"/Angle_Time_"+runName+".pkl"
    fname2 = loadDir+"/Clock_Count_"+runName+".pkl"
    if not os.path.exists(fname1):
        sys.exit("FATAL: Angle vs time data file %s not found\n" % (fname1))
    if not os.path.exists(fname2):
        sys.exit("FATAL: Clock vs count data file %s not found\n" % (fname2))

    #Load the data
    loadArr      = np.load(open(fname1,'rb'))
    time, angle  = np.asarray(loadArr).T
    time = time[::ds]
    angle = angle[::ds]
    loadArr      = np.load(open(fname2,'rb'))
    clock, count = np.asarray(loadArr).T
    clock = clock[::ds]
    count = count[::ds]
    #Force the data arrays to have an even number of values for easier handling of FFTs
    if len(time)%2:
        time  = time[:-1]
        angle = angle[:-1]
    if len(clock)%2:
        clock = clock[:-1]
        count = count[:-1]
    #Record the length of the resulting arrays
    alen = len(angle)
    clen = len(count)
    
    # ********************************************************
    # Analyze Data
    # ********************************************************

    #********** Analyze Angle vs Time Data **********

    print

    #Store frequency vs time
    print "Calculating angular frequency vs time..."
    freq  = np.diff(angle)/np.diff(time)
    ftime = time[:-1]
    np.save(open(saveDir+'Frequency_Time_'+runName+'.pkl','wb'), np.array([ftime, freq]).T)

    #Store acceleration vs time
    print "Calculating angular acceleration vs time..."
    accel = np.diff(freq)/np.diff(ftime)
    atime = ftime[:-1]
    np.save(open(saveDir+'Acceleration_Time_'+runName+'.pkl','wb'), np.array([atime, accel]).T)

    '''
    #Fit a sine to the sine data and store the residuals
    print "Fitting sine function to angle vs time data..."
    def fitFunc(x,freq,phase): return np.sin(2*np.pi*x*freq + phase)
    popt, pcov = opt.curve_fit(fitFunc, time[:1000], np.sin(angle[:1000]), p0=(1./(time[ticksPerRev/ds]-time[0]),angle[0]))
    print "     Fitted frequency at beginning = %.6f" % (popt[0])
    print "     Fitted phase at beginning = %.6f" % (popt[1])
    begin_freq = popt[0]
    begin_phse = popt[1]
    
    popt, pcov = opt.curve_fit(fitFunc, time[-1000:], np.sin(angle[-1000:]), p0=(1./(time[-1]-time[-ticksPerRev/ds]),angle[-ticksPerRev/ds]))
    print "     Fitted frequency at end = %.6f" % (popt[0])
    print "     Fitted phase at end = %.6f" % (popt[1])
    end_freq = popt[0]
    end_phse = popt[1]
    freq_bracket = np.array([begin_freq, end_freq])
    freq_lo = np.amin(freq_bracket)
    freq_hi = np.amax(freq_bracket)
    
    popt, pcov = opt.curve_fit(fitFunc, time, np.sin(angle), p0=(1./(time[ticksPerRev/ds]-time[0]),angle[0]))
    print "     Fitted frequency = %.6f" % (popt[0])
    print "     Fitted phase = %.6f" % (popt[1])
    fittedSine = fitFunc(time, *popt)
    residSine  = np.sin(angle) - fittedSine
    np.save(open(saveDir+'AngleSineFitResidual_Time_'+runName+'.pkl','wb'),   np.array([time,  residSine]).T)
    np.save(open(saveDir+'AngleSineFitResidual_Angle_'+runName+'.pkl','wb'),  np.array([angle, residSine]).T)

    # Calculate angle jitter
    print "Calculating angle jitter..."
    angleFit = np.polyfit(time, angle, deg=1)
    angleMean = np.polyval(angleFit, time)
    angleJitter = angle - angleMean
    jitterFit = np.polyfit(time, angleJitter, deg=1)
    jitterMean = np.polyval(jitterFit, time)
    interpJitter = angleJitter - jitterMean
    np.save(open(saveDir+'AngleJitter_Time_'+runName+'.pkl','wb'),  np.array([time,  interpJitter]).T)
    np.save(open(saveDir+'AngleJitter_Angle_'+runName+'.pkl','wb'), np.array([angle, interpJitter]).T)
    '''
    #********** Angle FFTs **********

    print

    #Window function for frequency
    print "Generating window function for frequency array..."
    fwindow = np.hanning(alen)

    #Equal step time and angle arrays for taking FFT
    interpTime  = np.linspace(time[0], time[-1], len(time))
    interpAngle = np.interp(interpTime, time, angle)
    timestep    = interpTime[1]  - interpTime[0]
    totTime     = interpTime[-1] - interpTime[0]

    #FFT the x-axis for time
    print "Generating angle FFT frequency array..."
    rfreq = np.fft.rfftfreq(alen, d=timestep)
    freq  = np.fft.fftfreq( alen, d=timestep)

    #FFT normalization for when using units
    print "Generating angle FFT normalization..."
    norm_old = np.sqrt(timestep/(alen**2))*(1./(np.trapz(fwindow)/alen))
    norm = np.sqrt(totTime/(alen**2))*(1./(np.trapz(fwindow)/alen))
    print "Normalization correction:", norm/norm_old
    '''
    #Performs the FFT of the sine of the angle
    print "Performing FFT of sine of angle..."
    sine_amp = norm*np.fft.rfft(np.sin(interpAngle)*fwindow)
    sine_pow  = np.power(abs(sine_amp),2)
    np.save(open(saveDir+'AngleSine_rFFT_'+runName+'.pkl','wb'), np.array([rfreq, sine_amp]).T)
    np.save(open(saveDir+'AngleSine_rPSD_'+runName+'.pkl','wb'), np.array([rfreq, sine_pow]).T)

    #Performs the FFT of the cosine of the angle
    print "Performing FFT of cosine of angle..."
    cosine_amp = norm*np.fft.rfft(np.cos(interpAngle)*fwindow)
    cosine_pow = np.power(abs(cosine_amp),2)
    np.save(open(saveDir+'AngleCosine_rFFT_'+runName+'.pkl','wb'), np.array([rfreq, cosine_amp]).T)
    np.save(open(saveDir+'AngleCosine_rPSD_'+runName+'.pkl','wb'), np.array([rfreq, cosine_pow]).T)

    #Performs the FFT of the complex exponential of the angle
    print "Performing FFT of complex exponential of angle..."
    comp_amp = norm*np.fft.fft(np.exp(-1j*interpAngle)*fwindow)
    comp_pow = np.power(abs(comp_amp),2)
    saveFreq = np.flip(np.split(freq,2),    axis=0).flatten()
    saveAmp  = np.flip(np.split(comp_amp,2),axis=0).flatten()
    savePow  = np.flip(np.split(comp_pow,2),axis=0).flatten()
    np.save(open(saveDir+'AngleComplexExp_FFT_'+runName+'.pkl','wb'), np.array([saveFreq, saveAmp]).T)
    np.save(open(saveDir+'AngleComplexExp_PSD_'+runName+'.pkl','wb'), np.array([saveFreq, savePow]).T)

    #Performs the FFT of the angle jitter
    print "Performing FFT of angle jitter..."
    jitter_amp = norm*np.fft.rfft(interpJitter*fwindow)
    jitter_pow  = np.power(abs(jitter_amp),2)
    np.save(open(saveDir+'AngleJitter_rFFT_'+runName+'.pkl','wb'), np.array([rfreq, jitter_amp]).T)
    np.save(open(saveDir+'AngleJitter_rPSD_'+runName+'.pkl','wb'), np.array([rfreq, jitter_pow]).T)    

    #Performs the FFT of the fit-subtracted residual
    print "Performing FFT of the fit-subtracted residual of the sine of angle..."
    resid_amp = norm*np.fft.rfft(residSine*fwindow)
    resid_pow = np.power(abs(resid_amp),2)
    np.save(open(saveDir+'AngleSineFitResidual_rFFT_'+runName+'.pkl','wb'), np.array([rfreq, resid_amp]).T)
    np.save(open(saveDir+'AngleSineFitResidual_rPSD_'+runName+'.pkl','wb'), np.array([rfreq, resid_pow]).T)

    #Performs the FFT of the notched sine of the angle
    print "Performing FFT of the notched sine of the angle..."
    n  = np.arange(1, 20)
    lo = freq_lo*n
    hi = freq_hi*n
    inds = np.array([])
    for i in range(len(n)):
        inds = np.concatenate((inds,np.where(np.logical_and(rfreq < hi[i], rfreq > lo[i]))[0]))
    inds = inds.astype(int)
    sine_amp_notch = sine_amp
    sine_amp_notch[inds] = 0.
    sine_pow_notch = sine_pow
    sine_pow_notch[inds] = 0.
    np.save(open(saveDir+'AngleSine_notched_rFFT_'+runName+'.pkl','wb'), np.array([rfreq, sine_amp_notch]).T)
    np.save(open(saveDir+'AngleSine_notched_rPSD_'+runName+'.pkl','wb'), np.array([rfreq, sine_pow_notch]).T)

    #Performs the FFT of the notched complex exponential of the angle
    print "Performing FFT of the notched complex exponential of the angle..."
    n  = np.arange(-10, 10)
    lo = freq_lo*n
    hi = freq_hi*n
    inds = np.array([])
    for i in range(len(n)):
        inds = np.concatenate((inds,np.where(np.logical_and(abs(freq) < abs(hi[i]), abs(freq) > abs(lo[i])))[0]))
    inds = inds.astype(int)
    comp_amp_notch = comp_amp
    comp_amp_notch[inds] = 0.
    comp_pow_notch = comp_pow
    comp_pow_notch[inds] = 0.
    np.save(open(saveDir+'AngleComplexExp_notched_FFT_'+runName+'.pkl','wb'), np.array([freq, comp_amp_notch]).T)
    np.save(open(saveDir+'AngleComplexExp_notched_PSD_'+runName+'.pkl','wb'), np.array([freq, comp_pow_notch]).T)
    
    #Performs the inverse FFT of the notched sine of the angle
    print "Performing inverse FFT of the notched sine of the angle..."
    comp_inv = np.fft.ifft(comp_amp_notch)
    tstep    = 1./(freq[1]-freq[0])
    time_inv = np.arange(0, tstep*len(comp_inv), tstep)
    np.save(open(saveDir+'AngleComplexExp_notched_iFFT_'+runName+'.pkl','wb'), np.array([time_inv, comp_inv.real, comp_inv.imag]).T)

    #********** Analyze Clock vs Count Data **********

    print
    
    #Calculate the clock jitter
    print "Calculating clock jitter..."
    clockFit = np.polyfit(count, clock, deg=1)
    clockMean = np.polyval(clockFit, count)
    clockJitter = clock - clockMean
    clockJitterFit = np.polyfit(count, clock, deg=1)
    clockJitterMean = np.polyval(clockJitterFit, count)
    interpClockJitter = clockJitter - clockJitterMean
    np.save(open(saveDir+'ClockJitter_Count_'+runName+'.pkl','wb'),  np.array([count, interpClockJitter]).T)
    np.save(open(saveDir+'ClockJitter_Clock_'+runName+'.pkl','wb'), np.array([clock, interpClockJitter]).T)

    #********** Clock FFTs **********

    print

    #Window function for counts
    print "Generating window function for counts..."
    cwindow = np.hanning(clen)

    #FFT Normalization
    print "Generating clock FFT normalization..."
    norm = np.sqrt(1/(clen**2))*(1./(np.trapz(cwindow)/clen))

    # FFT the x-axis for counts
    print "Generating count FFT frequency array..."
    crfreq = np.fft.rfftfreq(clen)
    cfreq  = np.fft.fftfreq(clen)

    #Performs the FFT of the sine of the raw clock output
    print "Performing FFT of sine of clock..."
    clockSine_amp = np.fft.rfft(np.sin(2.*np.pi*(clock/ticksPerRev))*cwindow)
    clockSine_pow = np.power(abs(clockSine_amp),2)
    np.save(open(saveDir+'ClockSine_rFFT_'+runName+'.pkl','wb'), np.array([crfreq, clockSine_amp]).T)
    np.save(open(saveDir+'ClockSine_rPSD_'+runName+'.pkl','wb'), np.array([crfreq, clockSine_pow]).T)

    #Performs the FFT of the cosine of the raw clock output
    print "Performing FFT of cosine of clock..."
    clockCosine_amp = np.fft.rfft(np.cos(2.*np.pi*(clock/ticksPerRev))*cwindow)
    clockCosine_pow = np.power(abs(clockCosine_amp),2)
    np.save(open(saveDir+'ClockCosine_rFFT_'+runName+'.pkl','wb'), np.array([crfreq, clockCosine_amp]).T)
    np.save(open(saveDir+'ClockCosine_rPSD_'+runName+'.pkl','wb'), np.array([crfreq, clockCosine_pow]).T)

    #Performs the FFT of the complex exponential of the raw clock input
    print "Performing FFT of complex exponential of clock..."
    clockComp_amp = norm*np.fft.fft(np.exp(-1j*2.*np.pi*(clock/ticksPerRev))*cwindow)
    clockComp_pow = np.power(abs(clockComp_amp),2)
    saveFreq = np.flip(np.split(cfreq,2),        axis=0).flatten()
    saveAmp  = np.flip(np.split(clockComp_amp,2),axis=0).flatten()
    savePow  = np.flip(np.split(clockComp_pow,2),axis=0).flatten()
    np.save(open(saveDir+'ClockComplexExp_FFT_'+runName+'.pkl','wb'), np.array([saveFreq, saveAmp]).T)
    np.save(open(saveDir+'ClockComplexExp_PSD_'+runName+'.pkl','wb'), np.array([saveFreq, savePow]).T)

    # Performs the FFT of the clock jitter
    print "Performing FFT of clock jitter..."
    clockJitter_amp = norm*np.fft.rfft(interpClockJitter*cwindow)
    clockJitter_pow  = np.power(abs(clockJitter_amp),2)
    np.save(open(saveDir+'ClockJitter_rFFT_'+runName+'.pkl','wb'), np.array([crfreq, clockJitter_amp]).T)
    np.save(open(saveDir+'ClockJitter_rPSD_'+runName+'.pkl','wb'), np.array([crfreq, clockJitter_pow]).T)
    '''
    print 'Done'
